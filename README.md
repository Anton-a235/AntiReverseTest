# AntiReverseTest
Тестирование методов защиты от исследования программы, разработанной на компилируемом языке программирования

## Вступление
Для демонстрации разработана простая консольная программа, которая производит вычисление хэш-сумм по алгоритмам MD5 и SHA-1 от строк, вводимых пользователем.
В программе использовано два метода защиты:
1. Защищенные страницы памяти - защита от дампирования
2. Вызов целевой функции через ложный вызов другой функции, уязвимой к переполнению буфера - усложнение восстановления алгоритма при исследовании.

Приведенная реализация методов имеет множество недочетов, не является полноценной и служит лишь для демонстрации. Программа разработана исключительно в исследовательских целях.

## Защищенные страницы памяти
Для защиты от снятия дампа памяти процесса применим защищенные страницы памяти. Страницы, содержащие защищаемый код, будут упакованы (в нашем проекте просто используем XOR) и помечены атрибутом PAGE_GUARD при запуске программы. При обращении к защищенной странице возбуждается исключение EXCEPTION_GUARD_PAGE. Наша задача – обработать это исключение, распаковать защищаемый код и передать управление коду программы.

Для установки защиты страниц памяти используем TLS callback – функция, которая запускается операционной системой в контексте процесса до того, как начнётся выполнение с точки входа.
Функция установки «кастомного» обработчика исключений имеет следующий прототип на языке C:
```
EXTERN_C VOID set_exception_handler(DWORD address);
```
и реализована полностью на языке MASM в файле set_exception_handler.asm.

Данная функция устанавливает реализованную в проекте функцию user_exception_dispatcher() в качестве первого и единственного обработчика исключений в цепочке SEH. В поле Next, указывающем на следующий обработчик, устанавливается значение 0xFFFFFFFF – признак конца цепочки.

![image](https://user-images.githubusercontent.com/88583217/204514298-b672215d-e312-46da-804a-02bb280c5ee8.png)

Для наглядности обработчик выводит сообщение при обращении к защищенным страницам, затем распаковывает код и возвращает управление.

![image](https://user-images.githubusercontent.com/88583217/204514693-a99ff5c8-ec9f-4f3a-85f2-2ddb79e60d6d.png)

Сравним в IDA Pro дизассемблированный код функции SHA1Init() по адресу 0x00413410 в исходном исполняемом файле и в дампе, снятом Scylla.

![image](https://user-images.githubusercontent.com/88583217/204515165-8d2796e7-eece-4cd4-90fb-9fa505ee6bd9.png)

Видим, что дизассемблер вместо кода функции видит «мусор» – упакованный код.

Защита страниц памяти может быть эффективной защитой против дампирования. Реализация, представленная в данной работе, сама по себе не является полноценной защитой, а только демонстрирует работу исследуемого механизма. Для эффективной защиты предполагается применять данный подход в упаковщиках, чтобы сам исполняемый файл уже содержал упакованный код, а при запуске только устанавливался атрибут PAGE_GUARD защищаемых страниц. А в представленной реализации код «упаковывается» (кодируется операцией XOR) и страницы защищаются при запуске процесса, при этом оригинальный код содержится в файле в открытом виде.

## Вызов функции через переполнение буфера
Заменим в программе стандартный вызов функции md5() на комбинацию переполнения буфера с вызовом инструкции RETN. Данная технология программирования позволяет исполнять произвольный код при эксплуатации уязвимостей типа переполнения буфера. При этом нет необходимости записывать свой код в адресное пространство, он подбирается по частям из имеющегося кода таким образом, чтобы в конце каждой части стояла инструкция возврата RETN. В нашем случае таким подготовленным кодом является функция md5(), а функцию, уязвимую к переполнению буфера (стека), названа f_rop() и реализована на ассемблере в файле f_rop.asm.

Прототип этой функции на C объявим так:
```
EXTERN_C VOID f_rop(char* buf, char* str, size_t len);
```
Функция принимает 3 аргумента: первый – строка, которая переполнит стек, остальные два для функции md5(). Однако в определении мы описываем её как функцию без параметров. Это связано с тем, что транслятор в составе Visual Studio функциям, имеющим параметры, автоматически дописывает пролог вида:
```
PUSH EBP
MOV EBP, ESP
```
Этот код создаёт в стеке локальный фрейм, который используется функцией для работы с локальными переменными, сохраняя перед этим в стеке старое значение EBP. Это помешало бы нам эксплуатации переполнения. Собственно, код функции просто копирует строку buf в маленький буфер размером 4 байта, за которым сразу идёт адрес возврата из функции. Строка buf будет более 4 байт, что и вызовет перезапись адреса возврата.

Перед вызовом функции f_rop() yеобходимо подготовить эту самую строку s_rop для передачи в функцию. Байты с 4-го по 7-й заполняются байтами адреса функции md5(). Знать заранее её адрес не нужно, он определяется в ходе выполнения.
```
// настраиваем буфер s_rop для вызова функции md5() через переполнение буфера в f_rop()
DWORD p_md5 = (DWORD)&md5;
s_rop[4] = (CHAR) * (PBYTE)&p_md5;
s_rop[5] = (CHAR) * ((PBYTE)&p_md5 + 1);
s_rop[6] = (CHAR) * ((PBYTE)&p_md5 + 2);
s_rop[7] = 0;
```
После этого нужно просто заменить вызов
```
md5(msg, len);
```
на вызов
```
f_rop(s_rop, msg, len);
```
Когда в программе запрашивается расчёт суммы MD5, вызывается f_rop(), как описано выше. В дизассемблированном виде это выглядит так:

![image](https://user-images.githubusercontent.com/88583217/204517777-68de3e7b-45b8-4c34-8e0a-029f5d5eb01a.png)

Параметры, передаваемые функции лежат на вершине стека в соответствии с соглашением о вызовах __cdecl. Затем код функции f_rop() выделяет 4 байта на вершине стека для копирования строки s_rop, сохраняет её адрес в регистр EDX и перезаписывает в стеке адрес строки на адрес возврата, дублируя его. Это нам нужно, чтобы не потерять адрес, куда нужно будет вернуть управление после выполнения «произвольного» кода. Стек перед копированием строки изображен на рисунке ниже.

![image](https://user-images.githubusercontent.com/88583217/204518147-7af855b6-3070-462f-954c-8739bf118568.png)

После копирования первый адрес возврата окажется перезаписанным. Переполненный стек с подготовленной последовательностью адресов возврата показан на рисунке ниже. Выделенное на рисунке значение и есть адрес функции md5(). Теперь переходы будут выполнятся с помощью команды RETN.

![image](https://user-images.githubusercontent.com/88583217/204518323-4b15240b-58f0-4e2c-affe-57c17c24a163.png)

Остаётся освободить выделенный буфер из 4 байт и выполнить RETN, и выполнение перейдёт на функцию md5(). К этому моменту стек будет выглядеть так, каким он должен быть при нормальном вызове функции.

![image](https://user-images.githubusercontent.com/88583217/204518429-b68cad60-6746-4ebf-b10a-8a313980d258.png)

Далее происходит обычное выполнение программы с возвратом управления в точку вызова.

Такой подход может усложнить анализ программ и восстановление алгоритма, так как такой способ вызова функции совершенно не очевиден для дизассемблера. Использование этого метода требует тщательной отладки и тестирования. Этот подход способен ввести в заблуждение исследователя даже при наличии исходных текстов, что видно на примере графа вызовов в программе Understand.

![image](https://user-images.githubusercontent.com/88583217/204518913-cb21084d-8cbb-435c-984f-615fa7d635ac.png)


